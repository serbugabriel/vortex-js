### **VortexJS: Hybrid Execution & Async Resiliency**

> **Status:** Stable
> **Focus:** Hybrid VM Architecture, Generator Fidelity, and Await Safety
> **Date:** Dec 31, 2025

This document details the architectural shift to "Hybrid Execution Mode," enabling the Virtual Machine to handle both synchronous and asynchronous functions without forcing a Promise-based return type on synchronous logic. This resolves critical crashes involving `TypeError: .then is not a function` and restores compatibility with standard synchronous generators.

---

```javascript
// 1. Synchronous Function
// MUST block and return value directly, not a Promise.
function greetSync(name) {
  "use vortex";
  console.log("--- Sync Function Started ---");
  return `Hello, ${name}!`;
}

// 2. Asynchronous Function
// MUST return a Promise and suspend execution.
async function fetchGreetingAsync(name) {
  "use vortex";
  console.log("--- Async Function Started (Simulating API call...) ---");
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`Hello, ${name}!`);
    }, 500);
  });
}

// 3. The "Crash" Case (Await on non-Promise)
// The VM previously assumed all awaited values were Promises.
async function edgeCase() {
  const val = await 42; // Caused VM crash
  return val;
}

// 4. Generator Fidelity
// Sync generators must remain sync iterables.
function* syncGen() {
  yield 1;
  yield 2;
}
```

</details>

## 1. Hybrid VM Architecture

### The "Always Async" Problem

**Error:** `Sync functions returning Promises`
**Analysis:**
Previously, the VM runtime function `const V = async (...) => { ... }` was explicitly defined as `async`. This meant that even purely synchronous virtualized functions (like `greetSync`) returned a `Promise`.

- This broke caller expectations (e.g., `const result = greetSync(...)` received a Promise instead of a string).
- It forced unnecessary microtask scheduling, destroying the performance of tight loops.

**Solution:**

- **Synchronous Signature:** The VM function `V` is now defined as a standard synchronous function (`async: false`).
- **Dynamic Return Type:**
- If the execution path is purely synchronous, `V` returns the result object directly (e.g., `{ _: 1, v: "Hello" }`).
- If the execution hits an `AWAIT` opcode, `V` manually constructs and returns a `Promise` chain.

- **Smart Wrappers:** The function wrappers generated by `ASTGenerator` now check the original function type. Sync functions unwrap the result immediately (`v.v`), while async functions wrap the result in `Promise.resolve(v).then(...)`.

---

## 2. Await Safety

### The "Non-Promise Await" Crash

**Error:** `TypeError: M[89].then is not a function`
**Analysis:**
In the `AWAIT` opcode, the VM attempted to attach a continuation directly to the register value: `M[op.promiseVar].then(...)`.
If the user code awaited a non-Promise value (e.g., `await 42` or `await syncResult`), `M[op.promiseVar]` was a number or string, which does not have a `.then` method, causing the VM to crash.

**Solution:**

- **Promise Normalization:** The `AWAIT` opcode AST generation was updated to wrap the operand in `Promise.resolve()` before attaching handlers.
- _Before:_ `register.then(callback)`
- _After:_ `Promise.resolve(register).then(callback)`

- This ensures that even if the virtualized code awaits a primitive, the VM handles it correctly as a resolved Promise.

---

## 3. Generator Type Fidelity

### The "Async Iterator" Mismatch

**Error:** `Sync Generators converted to Async Generators`
**Analysis:**
The `createGeneratorWrapper` method previously hardcoded the wrapper as `async function*`.

- This forced `Symbol.iterator` (sync) to become `Symbol.asyncIterator`.
- Code expecting standard `for..of` loops broke because the iterator returned Promises instead of `{ value, done }` objects synchronously.

**Solution:**

- **Type-Aware Wrappers:** The generator wrapper builder now accepts an `isAsync` flag derived from the original source function.
- **Conditional Await:** The wrapper only uses `await V(...)` if the original generator was async. For synchronous generators, it calls `V(...)` synchronously and yields the result immediately, preserving the correct iterator protocol.

---

## 4. Verification

**Input Code:**

```javascript
console.log(greetSync("Alice"));
// Expected: "Hello, Alice!" (Immediate string)

const gen = syncGen();
console.log(gen.next());
// Expected: { value: 1, done: false } (Immediate object)
```

**Verified Output:**

```text
--- Sync Function Started ---
Hello, Alice!
{ value: 1, done: false }

```

_The VM now correctly distinguishes between execution modes. The test suite passed **79/79** tests, confirming that edge cases including `Promise.all`, synchronous generators, and mixed async/sync call stacks are fully functional._
