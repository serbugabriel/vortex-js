### **VortexJS: Destructuring, Scope & Loop Resilience**

> **Status:** Stable
> **Focus:** Complex Assignments, Closure Memory Safety, and Loop Transformation
> **Date:** Dec 24, 2025

This document details the series of fixes applied to the VortexJS obfuscation engine to support destructuring assignments, ensure correct closure behavior within the VM, and handle synchronous/asynchronous loop transformations robustly.

---

## 1. Destructuring & Implicit Strings

### The Destructuring Crash

**Error:** `Unsupported assignment target type: ArrayPattern`
**Analysis:**
The IR Generator's `ExpressionHandler` lacked logic to process destructuring assignments (e.g., `[a, b] = [1, 2]`). It only supported direct identifier or member assignments.
**Solution:**

- **Recursive Unrolling:** Implemented a recursive strategy in `handleAssignmentExpression`. It breaks down `ArrayPattern` and `ObjectPattern` into sequential `MEMBER_ACCESS` and `ASSIGN` operations compatible with the state machine.
- **Sparse Array Support:** Added handling for sparse arrays (e.g., `[a, , b] = c`).

### The Missing String Bug

**Error:** `[StringCollector] String "0" was not found`
**Analysis:**
The destructuring logic converts numeric array indices (like `0` in `[a]`) into string property accessors (`arr["0"]`). The `StringCollector` previously only looked for explicit string literals, missing these implicitly generated strings.
**Solution:**

- **Enhanced Collection:** Updated `StringCollector` to visit `ArrayPattern` elements and `NumericLiteral` property keys, ensuring all numeric indices are pre-registered in the encrypted string array.

---

## 2. Closure & Memory Safety

### The "Stale Loop Count" Bug

**Behavior:** Variables updated inside closures (e.g., `setTimeout(() => count++)`) remained `0`.
**Analysis:**
Captured variables were passed into closures via an IIFE wrapper: `((count) => count++)(M[idx])`. Since numbers are primitives in JS, `count` was passed by **value**. The closure updated the local argument, not the actual VM register.
**Solution:**

- **Direct Memory Access:** Removed the primitive IIFE wrapper. The generator now directly replaces captured identifiers with `M[idx]` inside the function body, ensuring updates occur by **reference** to the live VM memory.

### The "VM Memory Frame" Crash

**Error:** `TypeError: M[...] is not a function` inside recursive/internal calls.
**Analysis:**
When the VM executed internal calls (like `trampoline`), it reused the `M` variable. Closures created during this time captured the mutable `M` reference. When executed later, they accessed the _current_ `M` (often the wrong stack frame) instead of the one they were born in.
**Solution:**

- **Memory Snapshotting:** Functions generated by the IR are now wrapped in an IIFE that explicitly captures the specific `M` instance: `((M) => function(...){ ... })(M)`. This freezes the correct memory frame for the closure.

---

## 3. Assignment & Loop Correctness

### The Assignment Target Bug

**Error:** `ReferenceError: x is not defined`
**Analysis:**
Babel's `path.isReferenced()` returns `false` for the left-hand side of assignments (e.g., `x` in `x = 5`). Consequently, the obfuscator skipped transforming `x` into `M[idx]`, leaving a raw identifier that didn't exist in the VM scope.
**Solution:**

- **Structural Detection:** Replaced `isReferenced()` with manual structural checks (e.g., ensuring we don't replace object keys `key: val` or function params). This correctly identifies assignment targets as memory accesses.

### The "Await in Sync" Error

**Error:** `ERROR: "await" can only be used inside an "async" function`
**Analysis:**
The `ForOfStatement` transformation unconditionally injected `await iterator.next()`. When applied to synchronous loops (like inside `Proxy.apply`), this generated invalid JavaScript.
**Solution:**

- **Conditional Await:** The generator now checks `path.node.await`. It injects `await` only for `for await (...)` loops.
- **Iterator Protocol:** It dynamically selects `Symbol.iterator` or `Symbol.asyncIterator` based on the loop type.

---

## 4. Summary of Verified Fixes

| Feature           | Input Code         | Previous Status        | Fixed Behavior              |
| ----------------- | ------------------ | ---------------------- | --------------------------- |
| **Destructuring** | `[a, b] = [1, 2]`  | **Build Fail**         | Correctly assigns variables |
| **Closures**      | `() => count++`    | **Value not updated**  | Updates VM Memory           |
| **Recursion**     | `trampoline(...)`  | **Runtime Crash**      | Correct Execution Context   |
| **Sync Loops**    | `for (let x of y)` | **Build Fail (await)** | Valid Sync Iteration        |
